I"<blockquote>
  <p><a href="https://leetcode-cn.com/problems/integer-break/description/">Leetcode:Integer-break</a></p>
</blockquote>

<p>算法一直是自己之前一直比较薄弱的方面，所以最近开始补习这方面的知识。</p>

<p>开始做的时候倾向于是一道数学题目，很多LeetCode上的题目都是数学类型的，如果了解了其背后的数学原理，对于给出相应的解法相对来说也是很简单的。对于算法的理解，每个人都能给出不同的定义，<a href="https://en.wikipedia.org/wiki/Algorithm">wiki</a>给出定义：</p>

<p><strong>In mathematics and computer science, an algorithm is an unambiguous specification of how to solve a class of problems.</strong></p>

<p>翻译过来：在计算机科学和数学中，算法是一种解决一类问题的规范，算法本质上也是一种数学模型，去解决实际的计算机问题。</p>

<p>这是一道典型的动态规划题目，动态规划这种算法最重要的一步就是总结归纳，也就是总结出子问题，归纳并找到状态转移方程。网上针对这道问题有很多解法，在完成之后也看了LeetCode上的解法，觉得自己的解法还是比其他方法有可取之处的，属于动态规划且时间复杂度为O(n)，这也是我写这篇文章的目的之一。</p>

<p>针对此题目，之前第一感觉就是拆分成相等的数应该是最大，很显然不是所有数都是可以拆分成相等的数，所以得出了一个直觉上的结论：拆分的数字之间的尽可能的小，乘积会最大。</p>

<p>一.总结</p>

<p>显然最小的能拆分的整数是2，所以从2开始，我们看看拆分成2个整数能否有规律：</p>

<p>2 = 1 + 1  显然最大为1 * 1 = 1；</p>

<p>3 = 1 + 2 = 2 + 1 最大为 2 * 1或者1 * 2；</p>

<p>4 = 2 + 2  最大为 2 * 2 = 4 ；</p>

<p>5 = 2 + 3  最大是 2 * 3 = 6；</p>

<p>6 = 3 + 3 最大是 3 * 3 = 9；</p>

<p>—————————分割线—————————</p>

<p>7 = 3 + 4 = 3 + (2 + 2)  最大是 3 * 2 * 2 = 3 * 4 = 12；</p>

<p>8 = 2 + 6 = 2 + (3 + 3) 最大是 2 * 3 * 3 = 18；</p>

<p>9 = 3 + 6 = 3 + (3 + 3) 最大是 3 * 3 * 3 = 27；</p>

<p>…….</p>

<p>细心的人可能会发现规律，发现拆分的数字最小的不是2就是3，这是因为 2和3是唯一两个拆分之后数字乘积比本身还要小的数字，所以根本就
没有必要去拆分，所以拆分出来的第一个数字必然是2和3其中一个。</p>

<p>二.归纳</p>

<p>根据之前总结的规律，分析出第一个数字是2或者3，设正整数n(n&gt;6)最大的乘积函数为F(n)，则要想乘积最大肯定是在2 * F(n-2)和3 * F(n-3)之间的最大值，因此动态规划的状态转移方程为：</p>

<p>F(n) = \(\begin{cases}
1 (n = 2)\\
2 (n = 3)\\
4 (n = 4)\\
6 (n = 5)\\
9 (n = 6)\\
Max(2 * F(n-2),3 * F(n-3)) (n &gt; 6)\\
\end{cases}\)</p>

<p>代码如下：</p>

<pre><code class="language-java">class Solution {
    public int integerBreak(int n) {
        int[] dp = new int[58];
        dp[1] = 1;
        dp[2] = 2;
        dp[3] = 4;
        dp[4] = 6;
        dp[5] = 9;

```
    for (int i = 6;i&lt;n;i++) {
        dp[i] = Math.max(2 * dp[i-2], 3 * dp[i-3]);
    }
    
    return dp[n-1];
}
```
}</code></pre>
:ET