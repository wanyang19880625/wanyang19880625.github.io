---
layout: post
title: 'Leetcode-343 '
# subtitle: 'leetcode-343'
date: 2018-12-16
categories: algorithm
tags: leetcode
---

>[Leetcode:Integer-break](https://leetcode-cn.com/problems/integer-break/description/)

算法一直是自己之前一直比较薄弱的方面，所以最近开始补习这方面的知识。

开始做的时候倾向于是一道数学题目，很多LeetCode上的题目都是数学类型的，如果了解了其背后的数学原理，对于给出相应的解法相对来说也是很简单的。对于算法的理解，每个人都能给出不同的定义，[wiki](https://en.wikipedia.org/wiki/Algorithm)给出定义：

**In mathematics and computer science, an algorithm is an unambiguous specification of how to solve a class of problems.**

翻译过来：在计算机科学和数学中，算法是一种解决一类问题的规范，算法本质上也是一种数学模型，去解决实际的计算机问题。


这是一道典型的动态规划题目，动态规划这种算法最重要的一步就是总结归纳，也就是总结出子问题，归纳并找到状态转移方程。网上针对这道问题有很多解法，在完成之后也看了LeetCode上的解法，觉得自己的解法还是比其他方法有可取之处的，属于动态规划且时间复杂度为O(n)，这也是我写这篇文章的目的之一。

针对此题目，之前第一感觉就是拆分成相等的数应该是最大，很显然不是所有数都是可以拆分成相等的数，所以得出了一个直觉上的结论：拆分的数字之间的尽可能的小，乘积会最大。

一.总结

显然最小的能拆分的整数是2，所以从2开始，我们看看拆分成2个整数能否有规律：

2 = 1 + 1  显然最大为1 * 1 = 1；

3 = 1 + 2 = 2 + 1 最大为 2 * 1或者1 * 2；

4 = 2 + 2  最大为 2 * 2 = 4 ；

5 = 2 + 3  最大是 2 * 3 = 6；

6 = 3 + 3 最大是 3 * 3 = 9；

---------------------------分割线---------------------------

7 = 3 + 4 = 3 + (2 + 2)  最大是 3 * 2 * 2 = 3 * 4 = 12；

8 = 2 + 6 = 2 + (3 + 3) 最大是 2 * 3 * 3 = 18；

9 = 3 + 6 = 3 + (3 + 3) 最大是 3 * 3 * 3 = 27；

.......

细心的人可能会发现规律，发现拆分的数字最小的不是2就是3，这是因为 2和3是唯一两个拆分之后数字乘积比本身还要小的数字，所以根本就
没有必要去拆分，所以拆分出来的第一个数字必然是2和3其中一个。

二.归纳

根据之前总结的规律，分析出第一个数字是2或者3，设正整数n(n>6)最大的乘积函数为F(n)，则要想乘积最大肯定是在2 * F(n-2)和3 * F(n-3)之间的最大值，因此动态规划的状态转移方程为：

F(n) = $$\begin{cases}
1 (n = 2)\\
2 (n = 3)\\
4 (n = 4)\\
6 (n = 5)\\
9 (n = 6)\\
Max(2 * F(n-2),3 * F(n-3)) (n > 6)\\
\end{cases}
$$

代码如下：

<pre><code class="language-java">class Solution {
    public int integerBreak(int n) {
        int[] dp = new int[58];
        dp[1] = 1;
        dp[2] = 2;
        dp[3] = 4;
        dp[4] = 6;
        dp[5] = 9;
        
        for (int i = 6;i<n;i++) {
            dp[i] = Math.max(2 * dp[i-2], 3 * dp[i-3]);
        }
        
        return dp[n-1];
    }
}</code></pre>
